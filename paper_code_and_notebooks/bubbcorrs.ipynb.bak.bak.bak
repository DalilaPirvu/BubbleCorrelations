{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bubble Correlations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random\n",
    "import math\n",
    "import seaborn\n",
    "import statistics as stat\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import scipy as scp\n",
    "import scipy.optimize as sco\n",
    "import scipy.signal as scs\n",
    "import scipy.special as ssp\n",
    "import scipy.integrate as sci\n",
    "from labellines import labelLines\n",
    "from collections import OrderedDict\n",
    "from itertools import zip_longest, groupby, cycle\n",
    "from numpy.random import seed, randn\n",
    "from scipy import stats\n",
    "from scipy.stats import shapiro, normaltest, anderson\n",
    "from statsmodels.graphics.gofplots import qqplot\n",
    "\n",
    "np_load_old = np.load\n",
    "np.load = lambda *a,**k: np_load_old(*a, allow_pickle=True, **k)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Simulation Parameters "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lamb =  1.5\n",
      "phi0 =  0.8975979010256552\n",
      "lenLat =  3162.2776601683795\n",
      "m2eff =  0.01\n",
      "dtout/dt =  32.0\n",
      "units =  2.0\n"
     ]
    }
   ],
   "source": [
    "nLat = 8192\n",
    "nTime = 256\n",
    "nSims = 20000\n",
    "minSim = 0\n",
    "simstep = 1\n",
    "\n",
    "lamb = 1. + 0.5; print('lamb = ', lamb)\n",
    "phi0 = 2.*np.pi / 7.; print('phi0 = ', phi0)\n",
    "\n",
    "nu = 2.*10**(-3)\n",
    "lenLat = 8 * 0.5 * 50. / np.sqrt(2. * nu); print('lenLat = ', lenLat)\n",
    "m2eff = 4. * nu * (- 1. + lamb**2); print('m2eff = ', m2eff)\n",
    "\n",
    "alpha = 16.\n",
    "phi_initial = np.pi\n",
    "\n",
    "nyq = nLat//2+1; spec = nyq//16; dx = lenLat/nLat; dk = 2.*np.pi/lenLat\n",
    "dt = dx/alpha; dtout = dt*nLat/nTime; print('dtout/dt = ', dtout/dt)\n",
    "light_cone = dtout/dx\n",
    "unit_conv = nLat/nTime/alpha; print('units = ', unit_conv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "filter_size =  4.542813258696356\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, '$\\\\phi$')"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "instanton_location = '/home/dpirvu/inst/unstable/dev/thick_wall_instanton_interp.dat'\n",
    "a = np.genfromtxt(instanton_location)\n",
    "coleman_bubble = 2*np.pi-a[:,1]\n",
    "xoffset = 50\n",
    "temp = coleman_bubble[len(coleman_bubble)//2-xoffset:len(coleman_bubble)//2+xoffset]\n",
    "tempcoords = a[len(coleman_bubble)//2-xoffset:len(coleman_bubble)//2+xoffset,0]\n",
    "peaks, _ = scs.find_peaks(temp)\n",
    "fwhm = scs.peak_widths(temp, peaks, rel_height=0.5)\n",
    "radius_Coleman_bubble = max(fwhm[0])/2.\n",
    "filter_size = radius_Coleman_bubble\n",
    "print('filter_size = ', filter_size)\n",
    "\n",
    "plt.plot(tempcoords/dx, temp)\n",
    "plt.plot(peaks-xoffset, temp[peaks], \"x\")\n",
    "[plt.hlines(fwhm[1][i], fwhm[2][i]-xoffset, fwhm[3][i]-xoffset, color=\"C2\") for i in range(len(fwhm[1]))]\n",
    "plt.xlabel(r'$r_{\\rm E}$'); plt.ylabel(r'$\\phi$')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "curvature =  0.014444477889845467\n",
      "wall_tension =  0.46497413771169294\n",
      "epsilon =  0.016\n",
      "R_coleman =  29.06088360698081\n",
      "wall_thkn =  80.67292631362025\n"
     ]
    }
   ],
   "source": [
    "def V(phi):\n",
    "    return ( -np.cos(phi) + 0.5 * lamb**2 * np.sin(phi)**2 ) * 4 * nu\n",
    "def dV(phi):\n",
    "    return ( np.sin(phi) + 0.5 * lamb**2 * np.sin(2*phi) ) * 4 * nu\n",
    "def ddV(phi):\n",
    "    return ( np.cos(phi) + lamb**2 * np.cos(2*phi) ) * 4 * nu\n",
    "\n",
    "right_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[np.pi, 2*np.pi], method='bounded')\n",
    "left_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[0, np.pi], method='bounded')\n",
    "right_left_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[2*np.pi, 3*np.pi], method='bounded')\n",
    "\n",
    "def F(x):\n",
    "    return V(x) - V(phi_initial)\n",
    "phi_upper_bound = sco.fsolve(F, 5.5)[0]\n",
    "phi_lower_bound = sco.fsolve(F, 1.5)[0]\n",
    "phi_upper_lower_bound = sco.fsolve(F, 8)[0]\n",
    "\n",
    "############################################################\n",
    "kappa = np.abs(ddV(right_phi_at_V_max.x))/(1 + dV(right_phi_at_V_max.x)**2)**1.5; print('curvature = ', kappa)\n",
    "wall_tension, err = sci.quad(lambda x: np.sqrt(2*(V(x) - V(2*np.pi))), np.pi, 2*np.pi); print('wall_tension = ', wall_tension)\n",
    "epsilon = V(np.pi) - V(2*np.pi); print('epsilon = ', epsilon)\n",
    "R_coleman = wall_tension/epsilon; print('R_coleman = ', R_coleman)\n",
    "wall_thkn = right_phi_at_V_max.x / np.sqrt( V(right_phi_at_V_max.x) - V(np.pi) ); print('wall_thkn = ', wall_thkn)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Import the Data "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "plots_file = '/home/dpirvu/big_plot_file/bubble_correlations/correlation_function/'\n",
    "def sim_location(sim):\n",
    "    return '/gpfs/dpirvu/bubble_correlations/t'+str(nTime)+'_x'+str(nLat)+'_len{:.4f}'.format(lenLat)+'_phi0{:.4f}'.format(phi0)+'_lamb{:.4f}'.format(lamb)+'_alph{:.4f}'.format(alpha)+'_spec'+str(spec)+'_sim'+str(sim)+'_fields.dat'\n",
    "def sim_suffix(phi0, lamb):\n",
    "    return '_for_phi0{:.4f}'.format(phi0)+'_len{:.4f}'.format(lenLat)+'_lamb{:.4f}'.format(lamb)+'_t'+str(nTime)+'_x'+str(nLat)\n",
    "def pickle_location(phi0, lamb):\n",
    "    return '/home/dpirvu/pickle_location/bubble_correlations/phi0'+str(int(20*np.pi/phi0))+'_lambda'+str(int(10*lamb))+'/'\n",
    "def pickle_corr_location(phi0, lamb, threshold, type):\n",
    "    return '/home/dpirvu/pickle_location/bubble_correlations/phi0'+str(int(20*np.pi/phi0))+'_lambda'+str(int(10*lamb))+'/th_correlator_type'+type+'_threshold{:.2f}'.format(threshold)\n",
    "\n",
    "def positive_data_file(phi0, lamb, minSim, maxSim, multiplier):\n",
    "    pickle = pickle_location(phi0, lamb)\n",
    "    suffix = sim_suffix(phi0, lamb)\n",
    "    return pickle+'positive_targets_sims'+str(minSim)+'_to'+str(maxSim-1)+'_multiplier'+str(multiplier)+suffix+'.npy'\n",
    "\n",
    "def negative_data_file(phi0, lamb, minSim, maxSim, multiplier):\n",
    "    pickle = pickle_location(phi0, lamb)\n",
    "    suffix = sim_suffix(phi0, lamb)\n",
    "    return pickle+'negative_targets_sims'+str(minSim)+'_to'+str(maxSim-1)+'_multiplier'+str(multiplier)+suffix+'.npy'\n",
    "\n",
    "def import_all_data(lamb, phi0, multiplier):\n",
    "    if lamb != 1.6:\n",
    "        a = np.load(positive_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "        ab = np.load(positive_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "        abc = np.load(positive_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "        abcd = np.load(positive_data_file(phi0, lamb, 12000, 16000, multiplier))\n",
    "        abcde = np.load(positive_data_file(phi0, lamb, 16000, 20000, multiplier))\n",
    "        args = (a, ab, abc, abcd, abcde)\n",
    "        positive_targets = np.concatenate(args).tolist()\n",
    "        all_sims = np.arange(len(positive_targets))\n",
    "\n",
    "        z = np.load(negative_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "        zy = np.load(negative_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "        zyx = np.load(negative_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "        zyxw = np.load(negative_data_file(phi0, lamb, 12000, 16000, multiplier))\n",
    "        zyxwv = np.load(negative_data_file(phi0, lamb, 16000, 20000, multiplier))\n",
    "        args = (z, zy, zyx, zyxw, zyxwv)\n",
    "        negative_targets = np.concatenate(args).tolist()\n",
    "    else:\n",
    "        a = np.load(positive_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "        ab = np.load(positive_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "        abc = np.load(positive_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "        args = (a, ab, abc)\n",
    "        positive_targets = np.concatenate(args).tolist()\n",
    "        all_sims = np.arange(len(positive_targets))\n",
    "\n",
    "        z = np.load(negative_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "        zy = np.load(negative_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "        zyx = np.load(negative_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "        args = (z, zy, zyx)\n",
    "        negative_targets = np.concatenate(args).tolist()\n",
    "    return positive_targets, negative_targets, all_sims"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "list_multiplier = []\n",
    "list_threshold = []\n",
    "list_type = ['++', '+-', '++--']\n",
    "\n",
    "overshoot_threshold = right_left_phi_at_V_max.x\n",
    "for multiplier in [0.75, 1, 1.25]:\n",
    "    threshold = right_phi_at_V_max.x + np.abs(right_phi_at_V_max.x-phi_upper_bound)*multiplier\n",
    "    list_multiplier.append(multiplier)\n",
    "    list_threshold.append(threshold)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmax = 1000\n",
    "xmin = 1\n",
    "tmax = 100\n",
    "tmin = -100\n",
    "\n",
    "xstep = 5\n",
    "tstep = 0.5*unit_conv\n",
    "\n",
    "MMmin = 2\n",
    "Rrange = np.arange(xmin, xmax+1, xstep)\n",
    "Trange = np.arange(tmin, tmax+1, tstep)*unit_conv\n",
    "\n",
    "xx = Rrange/(radius_Coleman_bubble/dx)\n",
    "#xx = Rrange/kappa\n",
    "\n",
    "MMxx = xx[MMmin-xmin:]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Correlation Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def correlator(data, PositiveTargets, NegativeTargets, all_sims, R, xstep, T, tstep):\n",
    "    r_correlator = []\n",
    "    for sim in all_sims:\n",
    "        if data == 0:\n",
    "            bubbleCoords = PositiveTargets[sim]\n",
    "        elif data == 1:\n",
    "            bubbleCoords = NegativeTargets[sim]\n",
    "        elif data == 2:\n",
    "            bubbleCoords = PositiveTargets[sim] + NegativeTargets[sim]\n",
    "#            print(PositiveTargets[sim], NegativeTargets[sim], bubbleCoords)\n",
    "\n",
    "        nBubbles = len(bubbleCoords)\n",
    "        bubNDens = nBubbles / (nLat * nTime)\n",
    "        area = 2.* xstep * tstep\n",
    "        if nBubbles != 0:\n",
    "            if nBubbles > 1.:\n",
    "                bubCounter = 0.\n",
    "                for bubloc in range(nBubbles):\n",
    "                    t0, x0 = bubbleCoords[bubloc]\n",
    "                    bdx = [(x0 - bubbleCoords[j][1]) for j in range(nBubbles) if j != bubloc]\n",
    "                    for d in range(len(bdx)):\n",
    "                        if bdx[d] >= nLat//2:\n",
    "                            bdx[d] = bdx[d] - nLat\n",
    "                        elif bdx[d] <= -nLat//2:\n",
    "                            bdx[d] = bdx[d] + nLat\n",
    "                    bdt = [(t0 - bubbleCoords[j][0])*unit_conv for j in range(nBubbles) if j != bubloc]\n",
    "                    bubCounter += np.sum([1 for l in range(len(bdx)) if (R <= np.abs(bdx[l]) < R + xstep and T <= bdt[l] < T + tstep)])\n",
    "                r_correlator.append( bubCounter / (nBubbles * bubNDens * area) - 1. )\n",
    "            else:\n",
    "                r_correlator.append(-1)\n",
    "    return np.mean(r_correlator), np.std(r_correlator)/np.sqrt(len(r_correlator)-1)\n",
    "\n",
    "def mixed_correlator(data, PositiveTargets, NegativeTargets, all_sims, R, xstep, T, tstep):\n",
    "    r_correlator_P, r_correlator_N = [], []\n",
    "    for sim in all_sims:\n",
    "        posBubbleCoords, negBubbleCoords = PositiveTargets[sim], NegativeTargets[sim]\n",
    "        nPosBubbles, nNegBubbles = len(posBubbleCoords), len(negBubbleCoords)\n",
    "        nBubbles = nPosBubbles + nNegBubbles\n",
    "        if nBubbles != 0:\n",
    "            if nPosBubbles > 1. and nNegBubbles > 1.:\n",
    "                bubNDens = nBubbles / (nLat * nTime)\n",
    "                area = 2.* xstep * tstep\n",
    "                bubCounterP, bubCounterN = 0., 0.\n",
    "\n",
    "                if data == 3:\n",
    "                    for bubloc in range(nPosBubbles):\n",
    "                        t0, x0 = posBubbleCoords[bubloc]\n",
    "                        pbdx = [(x0 - negBubbleCoords[j][1]) for j in range(nNegBubbles)]\n",
    "                        for d in range(len(pbdx)):\n",
    "                            if pbdx[d] >= nLat//2:\n",
    "                                pbdx[d] = pbdx[d] - nLat\n",
    "                            elif pbdx[d] <= -nLat//2:\n",
    "                                pbdx[d] = pbdx[d] + nLat\n",
    "                        pbdt = [(t0 - negBubbleCoords[j][0])*unit_conv for j in range(nNegBubbles)]\n",
    "                        bubCounterP += np.sum([1 for l in range(len(pbdx)) if (R <= np.abs(pbdx[l]) < R + xstep and T <= pbdt[l] < T + tstep)])\n",
    "                    r_correlator_P.append( bubCounterP / (nBubbles * bubNDens * area) - 1)\n",
    "\n",
    "                elif data == 4:\n",
    "                    for bubloc in range(nNegBubbles):\n",
    "                        t0, x0 = negBubbleCoords[bubloc]\n",
    "                        nbdx = [(x0 - posBubbleCoords[j][1]) for j in range(nPosBubbles)]\n",
    "                        for d in range(len(nbdx)):\n",
    "                            if nbdx[d] >= nLat//2:\n",
    "                                nbdx[d] = nbdx[d] - nLat\n",
    "                            elif nbdx[d] <= -nLat//2:\n",
    "                                nbdx[d] = nbdx[d] + nLat\n",
    "                        nbdt = [(t0 - posBubbleCoords[j][0])*unit_conv for j in range(nPosBubbles)]\n",
    "                        bubCounterN += np.sum([1 for l in range(len(nbdx)) if (R <= np.abs(nbdx[l]) < R + xstep and T <= nbdt[l] < T + tstep)])\n",
    "                    r_correlator_N.append( bubCounterN / (nBubbles * bubNDens * area) - 1)\n",
    "            else:\n",
    "                if data == 3:\n",
    "                    r_correlator_P.append(-1)\n",
    "                elif data == 4:\n",
    "                    r_correlator_N.append(-1)\n",
    "    if data == 3:\n",
    "        return np.mean(r_correlator_P), np.std(r_correlator_P)/np.sqrt(len(r_correlator_P)-1)\n",
    "    elif data == 4:\n",
    "        return np.mean(r_correlator_N), np.std(r_correlator_N)/np.sqrt(len(r_correlator_N)-1)\n",
    "\n",
    "def distrib(sim_min, sim_max, data, PositiveTargets, NegativeTargets, all_sims, R, xstep, T, tstep):\n",
    "    r_correlator = []\n",
    "    for sim in all_sims[sim_min : sim_max]:\n",
    "        if data == 0:\n",
    "            bubbleCoords = PositiveTargets[sim]\n",
    "        elif data == 1:\n",
    "            bubbleCoords = NegativeTargets[sim]\n",
    "        elif data == 2:\n",
    "            bubbleCoords = PositiveTargets[sim] + NegativeTargets[sim]\n",
    "\n",
    "        nBubbles = len(bubbleCoords)\n",
    "        bubNDens = nBubbles / (nLat * nTime)\n",
    "        area = 2.* xstep * tstep\n",
    "        if nBubbles != 0:\n",
    "            if nBubbles > 1.:\n",
    "                bubCounter = 0.\n",
    "                for bubloc in range(nBubbles):\n",
    "                    t0, x0 = bubbleCoords[bubloc]\n",
    "                    bdx = [(x0 - bubbleCoords[j][1]) for j in range(nBubbles) if j != bubloc]\n",
    "                    for d in range(len(bdx)):\n",
    "                        if bdx[d] >= nLat//2:\n",
    "                            bdx[d] = bdx[d] - nLat\n",
    "                        elif bdx[d] <= -nLat//2:\n",
    "                            bdx[d] = bdx[d] + nLat\n",
    "                    bdt = [(t0 - bubbleCoords[j][0])*unit_conv for j in range(nBubbles) if j != bubloc]\n",
    "                    bubCounter += np.sum([1 for l in range(len(bdx)) if (R <= np.abs(bdx[l]) < R + xstep and T <= bdt[l] < T + tstep)])\n",
    "                r_correlator.append( bubCounter / (nBubbles * bubNDens * area) - 1. )\n",
    "            else:\n",
    "                r_correlator.append(-1)\n",
    "    return np.mean(r_correlator)\n",
    "\n",
    "def mixed_distrib(sim_min, sim_max, data, PositiveTargets, NegativeTargets, all_sims, R, xstep, T, tstep):\n",
    "    r_correlator_P, r_correlator_N = [], []\n",
    "    for sim in all_sims[sim_min : sim_max]:\n",
    "        posBubbleCoords, negBubbleCoords = PositiveTargets[sim], NegativeTargets[sim]\n",
    "        nPosBubbles, nNegBubbles = len(posBubbleCoords), len(negBubbleCoords)\n",
    "        nBubbles = nPosBubbles + nNegBubbles\n",
    "        if nBubbles != 0:\n",
    "            if nPosBubbles > 1. and nNegBubbles > 1.:\n",
    "                bubNDens = nBubbles / (nLat * nTime)\n",
    "                area = 2.* xstep * tstep\n",
    "                bubCounterP, bubCounterN = 0., 0.\n",
    "\n",
    "                if data == 3:\n",
    "                    for bubloc in range(nPosBubbles):\n",
    "                        t0, x0 = posBubbleCoords[bubloc]\n",
    "                        pbdx = [(x0 - negBubbleCoords[j][1]) for j in range(nNegBubbles)]\n",
    "                        for d in range(len(pbdx)):\n",
    "                            if pbdx[d] >= nLat//2:\n",
    "                                pbdx[d] = pbdx[d] - nLat\n",
    "                            elif pbdx[d] <= -nLat//2:\n",
    "                                pbdx[d] = pbdx[d] + nLat\n",
    "                        pbdt = [(t0 - negBubbleCoords[j][0])*unit_conv for j in range(nNegBubbles)]\n",
    "                        bubCounterP += np.sum([1 for l in range(len(pbdx)) if (R <= np.abs(pbdx[l]) < R + xstep and T <= pbdt[l] < T + tstep)])\n",
    "                    r_correlator_P.append( bubCounterP / (nBubbles * bubNDens * area) - 1)\n",
    "\n",
    "                elif data == 4:\n",
    "                    for bubloc in range(nNegBubbles):\n",
    "                        t0, x0 = negBubbleCoords[bubloc]\n",
    "                        nbdx = [(x0 - posBubbleCoords[j][1]) for j in range(nPosBubbles)]\n",
    "                        for d in range(len(nbdx)):\n",
    "                            if nbdx[d] >= nLat//2:\n",
    "                                nbdx[d] = nbdx[d] - nLat\n",
    "                            elif nbdx[d] <= -nLat//2:\n",
    "                                nbdx[d] = nbdx[d] + nLat\n",
    "                        nbdt = [(t0 - posBubbleCoords[j][0])*unit_conv for j in range(nPosBubbles)]\n",
    "                        bubCounterN += np.sum([1 for l in range(len(nbdx)) if (R <= np.abs(nbdx[l]) < R + xstep and T <= nbdt[l] < T + tstep)])\n",
    "                    r_correlator_N.append( bubCounterN / (nBubbles * bubNDens * area) - 1)\n",
    "            else:\n",
    "                if data == 3:\n",
    "                    r_correlator_P.append(-1)\n",
    "                elif data == 4:\n",
    "                    r_correlator_N.append(-1)\n",
    "    if data == 3:\n",
    "        return np.mean(r_correlator_P)\n",
    "    elif data == 4:\n",
    "        return np.mean(r_correlator_N)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Check Spread of Data "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def data_spread(data, xrange, xstep, T, tstep):\n",
    "    colors = cycle(('b', 'g', 'r'))\n",
    "    for phi0, lamb in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6]):\n",
    "        fig, ax = plt.subplots(1, 1, figsize = (15, 4))\n",
    "        for multiplier, threshold in zip(list_multiplier, list_threshold):\n",
    "            if lamb != 1.6:\n",
    "                positive_targets1 = np.load(positive_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "                positive_targets2 = np.load(positive_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "                positive_targets3 = np.load(positive_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "                positive_targets4 = np.load(positive_data_file(phi0, lamb, 12000, 16000, multiplier))\n",
    "                positive_targets5 = np.load(positive_data_file(phi0, lamb, 16000, 20000, multiplier))\n",
    "                negative_targets1 = np.load(negative_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "                negative_targets2 = np.load(negative_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "                negative_targets3 = np.load(negative_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "                negative_targets4 = np.load(negative_data_file(phi0, lamb, 12000, 16000, multiplier))\n",
    "                negative_targets5 = np.load(negative_data_file(phi0, lamb, 16000, 20000, multiplier))\n",
    "                all_sims = np.arange(len(positive_targets1))\n",
    "                positive_targets = [positive_targets1, positive_targets2, positive_targets3, positive_targets4, positive_targets5]\n",
    "                negative_targets = [negative_targets1, negative_targets2, negative_targets3, negative_targets4, negative_targets5]\n",
    "            else:\n",
    "                positive_targets1 = np.load(positive_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "                positive_targets2 = np.load(positive_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "                positive_targets3 = np.load(positive_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "                negative_targets1 = np.load(negative_data_file(phi0, lamb, 0, 4000, multiplier))\n",
    "                negative_targets2 = np.load(negative_data_file(phi0, lamb, 4000, 8000, multiplier))\n",
    "                negative_targets3 = np.load(negative_data_file(phi0, lamb, 8000, 12000, multiplier))\n",
    "                all_sims = np.arange(len(positive_targets1))\n",
    "                positive_targets = [positive_targets1, positive_targets2, positive_targets3]\n",
    "                negative_targets = [negative_targets1, negative_targets2, negative_targets3]\n",
    "\n",
    "                \n",
    "            col = next(colors)\n",
    "            for pos_tg, neg_tg, i in zip(positive_targets, negative_targets, np.arange(len(positive_targets))):\n",
    "                if data != 3 and data != 4:\n",
    "                    correlation_function = np.asarray([correlator(data, pos_tg, neg_tg, all_sims, R, xstep, T, tstep) for R in xrange])\n",
    "                else:\n",
    "                    correlation_function = np.asarray([mixed_correlator(data, pos_tg, neg_tg, all_sims, R, xstep, T, tstep) for R in xrange])\n",
    "                if i != 0:\n",
    "                    ax.plot(xx[:len(xrange)], correlation_function[:len(xrange), 0], color=col, marker='o', ms=3)\n",
    "                else:\n",
    "                    ax.plot(xx[:len(xrange)], correlation_function[:len(xrange), 0], color=col, marker='o', ms=3, label = 'threshold = {:.2f}'.format(threshold))\n",
    "\n",
    "        ax.set(xlabel=r'$r/R_0$', ylabel=r'$\\xi_{pk}(r)$')\n",
    "        ax.legend(bbox_to_anchor=(1, 1))\n",
    "        plt.title('phi0'+str(int(20*np.pi/phi0))+', lambda'+str(int(10*lamb)))\n",
    "        plt.savefig(plots_file+'type'+str(data)+'_spread_of_algs_for_Xstep'+str(xstep)+'_Tstep'+str(tstep)+sim_suffix(phi0, lamb)+'.png')\n",
    "        plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n",
      "51\n"
     ]
    }
   ],
   "source": [
    "T = Trange[100]\n",
    "print(T)\n",
    "R = Rrange[10]\n",
    "print(R)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_spread(0, Rrange[:100:], xstep, T, tstep)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ch = 1000\n",
    "\n",
    "def negative_log_likelihood(params, data):\n",
    "    ''' better alternative using scipy '''\n",
    "    return -stats.poisson.logpmf(data, params[0]).sum()\n",
    "\n",
    "def poisson(x, lamb):\n",
    "#    return stats.poisson.pmf(x, lamb)\n",
    "    return stats.poisson.pmf(x, lamb)\n",
    "\n",
    "for phi0, lamb in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6]):\n",
    "    fig, ax = plt.subplots(1, len(list_multiplier), figsize = (16, 4))\n",
    "    for multiplier, threshold, j in zip(list_multiplier, list_threshold, np.arange(len(list_multiplier))):\n",
    "        positive_targets, negative_targets, all_sims = import_all_data(lamb, phi0, multiplier)\n",
    "        counter = []\n",
    "        err = correlator(0, positive_targets, negative_targets, all_sims, R, xstep, T, tstep)[-1]\n",
    "        for sim_min in range(0, len(all_sims), ch):\n",
    "            sim_max = sim_min + ch\n",
    "            counter.append(distrib(sim_min, sim_max, 0, positive_targets, negative_targets, all_sims, R, xstep, T, tstep))\n",
    "\n",
    "        # Triage\n",
    "#        counter = [i for i in counter if i != -1]\n",
    "#        counter = [i for i in counter if np.mean(counter)-np.std(counter)*3 < i < np.mean(counter)+np.std(counter)*3]\n",
    "        c = [i for i in counter if np.mean(counter)-np.std(counter)*3 < i < np.mean(counter)+np.std(counter)*3]\n",
    "        data = np.asarray(counter)\n",
    "\n",
    "        # Bin data\n",
    "        bins = np.linspace(min(data), max(data)+1, len(data))\n",
    "        entries, bin_edges, patches = ax[j].hist(data, bins=bins, density=True, label='Data')\n",
    "#        entries, bin_edges = np.histogram(data, bins=bins)\n",
    "        x_plot = 0.5 * (bin_edges[1:] + bin_edges[:-1])\n",
    "#        entries = entries / np.sum(entries)\n",
    "\n",
    "        # Minimize the negative log-Likelihood\n",
    "#        result = sco.minimize(negative_log_likelihood, x0=[1], args=(entries,), method='Powell')\n",
    "#        parameters = result.x\n",
    "#        print(result)\n",
    "\n",
    "        # Best fit to curve\n",
    "        parameters, _ = sco.curve_fit(poisson, x_plot, entries)\n",
    "\n",
    "        # Plot poisson-distribution with fitted parameter\n",
    "        ax[j].plot(x_plot, poisson(x_plot, *parameters), marker='o', linestyle='', label='Fit result')\n",
    "        ax[j].legend()\n",
    "\n",
    "        print('poisson mean on full data', np.sqrt(np.mean(counter)/(len(counter)-1)), 'and without tail', np.sqrt(np.mean(c))/(len(c)-1))\n",
    "        print('stdev of full data', np.std(counter)/np.sqrt(len(counter)-1), 'and without tail', np.std(c)/np.sqrt(len(c)-1), '\\nbest fit poisson param', np.sqrt(*parameters), '\\ngaussian err', err)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Compare algorithms "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#for phi0, lamb in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6]):\n",
    "def empirical_error(data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep, ch):\n",
    "    counter = []\n",
    "    for sim_min in range(0, len(all_sims), ch):\n",
    "        sim_max = sim_min + ch\n",
    "        if data != 3 and data != 4:\n",
    "            counter.append(distrib(sim_min, sim_max, data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep))\n",
    "        else:\n",
    "            counter.append(mixed_distrib(sim_min, sim_max, data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep))            \n",
    "    return np.std(counter)/np.sqrt(len(counter)-1)\n",
    "\n",
    "def compare_algs(data, xstep, T, tstep, ch):\n",
    "    for phi0, lamb in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6]):\n",
    "        fig, ax = plt.subplots(1, 1, figsize = (14, 5))\n",
    "        for multiplier, threshold, j in zip(list_multiplier, list_threshold, np.arange(len(list_multiplier))):\n",
    "            positive_targets, negative_targets, all_sims = import_all_data(lamb, phi0, multiplier)\n",
    "            rivolo0, emperr = [], []\n",
    "            for R in Rrange:\n",
    "                if data != 3 and data != 4:\n",
    "                    rivolo0.append(correlator(data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep))\n",
    "                    emperr.append(empirical_error(data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep, ch))\n",
    "                else:\n",
    "                    rivolo0.append(mixed_correlator(data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep))\n",
    "                    emperr.append(empirical_error(data, positive_targets, negative_targets, all_sims, R, xstep, T, tstep, ch))\n",
    "                    \n",
    "            rivolo0 = np.asarray(rivolo0)\n",
    "            ax.errorbar(xx, rivolo0[:len(Rrange), 0], yerr=emperr, uplims=True, lolims=True, color=col, label = 'threshold = {:.2f}'.format(threshold))\n",
    "#            ax.errorbar(xx, rivolo0[:len(Rrange), 0], yerr=rivolo0[:len(Rrange), 1], uplims=True, lolims=True, label = 'threshold = {:.2f}'.format(threshold))\n",
    "\n",
    "            if multiplier == 1:\n",
    "                type = '++'\n",
    "                prediction0 = np.load(pickle_corr_location(phi0, lamb, threshold, type)+'.npy')\n",
    "                prediction0 = np.mean(np.asarray(prediction0[:xmax-xstep:]).reshape(-1, int(xstep)), axis=1)\n",
    "                ax.plot(MMxx, prediction0, color='orange', ls='--', label='type'+str(type)+', threshold = {:.2f}'.format(threshold))\n",
    "\n",
    "        ax.set_title('phi0'+str(int(20*np.pi/phi0))+', lambda'+str(int(10*lamb)))\n",
    "        ax.set(xlabel=r'$r/R_0$', ylabel=r'$\\xi_{pk}(r)$')\n",
    "        ax.legend(bbox_to_anchor=(1, 1))\n",
    "        plt.savefig(plots_file+'type'+str(data)+'_compare_algs_for_Xstep'+str(xstep)+'_Tstep'+str(tstep)+sim_suffix(phi0, lamb)+'.png')\n",
    "        plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "compare_algs(0, xstep, T, tstep, ch)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Compare Bubble Correlators"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_correlator_functions(xstep, T, tstep):\n",
    "    for multiplier, threshold in zip(list_multiplier, list_threshold):\n",
    "        for phi0, lamb in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6]):\n",
    "            positive_targets, negative_targets, all_sims = import_all_data(lamb, phi0, multiplier)\n",
    "\n",
    "            rivolo0 = np.asarray([correlator(0, positive_targets, negative_targets, all_sims, R, xstep, T, tstep) for R in Rrange])\n",
    "            rivolo1 = np.asarray([correlator(1, positive_targets, negative_targets, all_sims, R, xstep, T, tstep) for R in Rrange])\n",
    "            rivolo2 = np.asarray([correlator(2, positive_targets, negative_targets, all_sims, R, xstep, T, tstep) for R in Rrange])\n",
    "            rivolo3 = np.asarray([mixed_correlator(3, positive_targets, negative_targets, all_sims, R, xstep, T, tstep) for R in Rrange])\n",
    "            rivolo4 = np.asarray([mixed_correlator(4, positive_targets, negative_targets, all_sims, R, xstep, T, tstep) for R in Rrange])\n",
    "\n",
    "            fig, ax = plt.subplots(1, 1, figsize = (15, 4))\n",
    "            ax.errorbar(xx, rivolo0[:len(Rrange), 0], yerr=rivolo0[:len(Rrange), 1], color='r', marker='o', ms=3, label=r'$++$')\n",
    "            ax.errorbar(xx, rivolo1[:len(Rrange), 0], yerr=rivolo1[:len(Rrange), 1], color='g', marker='o', ms=3, label=r'$--$')\n",
    "            ax.errorbar(xx, rivolo2[:len(Rrange), 0], yerr=rivolo2[:len(Rrange), 1], color='k', marker='*', ms=3, label=r'$++, --, +-, -+$')\n",
    "            ax.errorbar(xx, rivolo3[:len(Rrange), 0], yerr=rivolo3[:len(Rrange), 1], color='c', marker='*', ms=3, label=r'$+-$')\n",
    "            ax.errorbar(xx, rivolo4[:len(Rrange), 0], yerr=rivolo3[:len(Rrange), 1], color='m', marker='*', ms=3, label=r'$-+$')\n",
    "\n",
    "            ax.set(xlabel=r'$r/R_0$', ylabel=r'$\\xi_{pk}(r)$'); ax.legend(bbox_to_anchor=(1, 1))\n",
    "            plt.title('Bubble nucleation site correlation function; threshold = {:.2f}'.format(threshold))\n",
    "            plt.savefig(plots_file+'bubble_correlator_Xstep'+str(xstep)+'_Tstep'+str(tstep)+'_multiplier'+str(multiplier)+sim_suffix(phi0, lamb)+'.png')\n",
    "            plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot_correlator_functions(xstep, T, tstep)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_spacetime_correlator(data, xstep, tstep):\n",
    "    for multiplier, threshold in zip(list_multiplier[::], list_threshold[::]):\n",
    "        fig, ax = plt.subplots(1, 2, figsize = (12, 5))\n",
    "        im = [1, 1]\n",
    "        for phi0, lamb, i in zip([2*np.pi/6.6, 2*np.pi/7., 2*np.pi/6.6], [1.5, 1.5, 1.6], np.arange(3)):\n",
    "            positive_targets, negative_targets, all_sims = import_all_data(lamb, phi0, multiplier)\n",
    "\n",
    "            matrix = [[-5 for x in range(len(Rrange))] for t in range(len(Trange))]\n",
    "            for T in range(len(Trange)):\n",
    "                for R in range(len(Rrange)):\n",
    "                    a = Rrange[R]\n",
    "                    b = Trange[T]\n",
    "                    if data != 3 and data != 4:\n",
    "                        rivolo0 = correlator(data, positive_targets, negative_targets, all_sims, a, xstep, b, tstep)\n",
    "                    else:\n",
    "                        rivolo0 = mixed_correlator(data, positive_targets, negative_targets, all_sims, a, xstep, b, tstep)\n",
    "                    matrix[T][R] = rivolo0[0]\n",
    "\n",
    "            im[i] = ax[i].imshow(matrix, aspect='auto', interpolation='none', origin='lower', cmap='RdYlBu_r', extent=[Rrange[0], Rrange[-1], Trange[0], Trange[-1]])\n",
    "            ax[i].set(xlabel=r'$r$', ylabel=r'$t$')\n",
    "            clb = plt.colorbar(im[i], ax = ax[i])\n",
    "            clb.ax.set_title(r'$\\xi(r,t)$')\n",
    "            ax[i].title('phi0'+str(int(20*np.pi/phi0))+'_lambda'+str(int(10*lamb)))\n",
    "        plt.suptitle('Correlation function; threshold = {:.2f}'.format(threshold))\n",
    "        plt.savefig(plots_file+'type'+str(data)+'_correlator2D'+str(xstep)+'_Tstep'+str(tstep)+'_multiplier'+str(multiplier)+'.png')\n",
    "        plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_spacetime_correlator(0, xstep, tstep)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.7 (conda) - recommended",
   "language": "python",
   "name": "python37-conda"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
